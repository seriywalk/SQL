# Домашнее задание к занятию 6. «Troubleshooting»## Задача 1Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD-операция в MongoDB и её нужно прервать. Вы как инженер поддержки решили произвести эту операцию:- напишите список операций, которые вы будете производить для остановки запроса пользователя;` db.killOp(opid)`Завершает операцию, указанную идентификатором операции. Чтобы найти операции и их соответствующие идентификаторы используют еоманду`db.currentOp()`Возвращает документ, содержащий информацию о выполняемых операциях для экземпляра базы данных. - предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB.Определить медленные запросы выполнив db.currentOp() на запущенном экземпляре mongod.Просматривая временные параметры возвращаемого результата, мы можем определить, какие запросы отстают. После определения этих запросов мы используем помощник explain для этих запросов, чтобы получить более подробную информацию, например, использует ли запрос какой-либо индекс. Если индекс не используется постоить его.## Задача 2Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. Причём отношение количества записанных key-value-значений к количеству истёкших значений есть величина постоянная иувеличивается пропорционально количеству реплик сервиса. При масштабировании сервиса до N реплик вы увидели, что:- сначала происходит рост отношения записанных значений к истекшим,- Redis блокирует операции записи.Как вы думаете, в чём может быть проблема?По сути, это означает, что если в базе данных имеется много-много ключей, срок действия которых истекает в одну и ту же секунду, и они составляют не менее 25% от текущей совокупности ключей с установленным сроком действия, Redis может заблокировать, чтобы процент ключей, срок действия которых уже истек, был ниже 25%.Этот подход необходим для того, чтобы избежать использования слишком большого объема памяти для ключей, срок действия которых уже истек, и обычно он абсолютно безвреден, поскольку странно, что срок действия большого количества ключей истекает в одну и ту же секунду, но не исключено, что пользователь активно использовал EXPIREAT в то же время в Unix.## Задача 3Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей в таблицах базыпользователи начали жаловаться на ошибки вида:```pythonInterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '```Как вы думаете, почему это начало происходить и как локализовать проблему?Какие пути решения этой проблемы вы можете предложить?1. Проверить работает ли служба MySQL`mysql> show global status like 'uptime';`Чем больше значение вреени работы службы, тем она безотказнее.2. Проверить таймаут подключеник к MySQL. Временя ожидания неинтерактивного соединения (`mysql> show global variables like '%timeout';`Возможно есть смысл его увеличить.3. Проверить не отключал ли кто-то сервис ручками.`mysql> show global status like 'com_kill';`4. Проверить не превышает ли запрос mySQL значение из файла настройкиЭкспортировать запрос в файл с помощью `select * > outfile,``mysql> show global variables like 'max_allowed_packet';`если размер файла превышает значение в конф файле, отредактирровать файл настроек.5. Возможно у клиента проблема с подклюением к базе данных.## Задача 4Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с большим объёмом данных лучше, чем MySQL.После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:`postmaster invoked oom-killer`Как вы думаете, что происходит?out-of-memory killer вызывается когда системе не хватает оперативной памяти. Как бы вы решили эту проблему?Самое простое - увеличить ОЗУ для сервера postgresql.Linux может перегружать память процессами, этим поведением можно управлять с помощью настроек ядра Linux. Для используется параметр `vm.overcommit_memory`. Чтобы избежать необходимости использовать OOM-Killer для остановки PostgreSQL, рекомендуется установить значение `vm .overcommit_memory` **равным 2**. Это не позволит на 100% избежать ООМ-killer, но уменьшит вероятность завершения процесса PostgreSQL.Также поведением OOM-killer можно управлять с помощью переменной cat / proc / sys /vm /swappiness. Эти значения определяют настройки ядра для обработки возможности замены страниц. Чем больше значение, тем меньше вероятность того, что ООМ остановит процесс, но это влияет на эффективность базы данных из-за ввода-вывода. Меньшее значение переменной, управляющей возможностью замены, означает, что существует более высокая вероятность того, что в систему включится ООМ-убийца, но это также улучшает производительность базы данных. Значение по умолчанию равно 60, но если вся база данных умещается в памяти, рекомендуется установить это значение равным 1.---### Как cдавать заданиеВыполненное домашнее задание пришлите ссылкой на .md-файл в вашем репозитории.---